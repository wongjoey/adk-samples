import logging
import json
from typing import Any, Dict, Optional

from google.adk.tools.base_tool import BaseTool
from google.adk.tools.tool_context import ToolContext
from google.adk.auth import AuthConfig, AuthHandler # Import Auth types

# Define the key suffix used by the ADK to store exchanged credentials
SNOW_LOGIN_TOOL_NAME = "get_current_user" # The tool that performs the login
SNOW_ACCESS_TOKEN_KEY = "SNOW_ACCESS_TOKEN" # Key to store/retrieve the extracted token
SNOW_REFRESH_TOKEN_KEY = "SNOW_REFRESH_TOKEN" # Key to store/retrieve the extracted token

SNOW_CONNECTOR_TOOL_PREFIX = "snow_connector_tool" # Prefix for tools needing dynamic auth
DYNAMIC_AUTH_PARAM_NAME = "dynamic_auth_config" # Name of the parameter to inject
DYNAMIC_AUTH_INTERNAL_KEY = "oauth2_auth_code_flow.access_token" # Internal key for the token

# Set up logging for visibility
logger = logging.getLogger(__name__)
logging.basicConfig(level=logging.INFO) # Adjust level as needed

def _inject_dynamic_auth(
    tool: BaseTool,
    args: Dict[str, Any],
    tool_context: ToolContext,
    token_state_key: str
):
    """
    Helper function to inject dynamic_auth_config using a token from session state.
    """
    logger.info(f"Tool '{tool.name}' requires dynamic auth. Checking state key '{token_state_key}' for token.")
    session_state = tool_context.state
    access_token = session_state.get(token_state_key)

    if access_token:
        # Construct the dynamic auth config
        dynamic_auth_config = {DYNAMIC_AUTH_INTERNAL_KEY: access_token}
        # Inject or overwrite the parameter in the arguments AS A JSON STRING
        args[DYNAMIC_AUTH_PARAM_NAME] = json.dumps(dynamic_auth_config)
        logger.info(f"Injected/Updated '{DYNAMIC_AUTH_PARAM_NAME}' in arguments.")
        logger.info(f"Arguments after injection: {args}")
    else:
        # Token not found, log a warning. The tool call will likely fail.
        logger.warning(f"'{token_state_key}' not found in session state. Cannot inject dynamic auth for '{tool.name}'. Tool call might fail.")

def before_tool_run_interceptor(
    tool: BaseTool,
    args: Dict[str, Any],
    tool_context: ToolContext,
) -> Optional[Dict[str, Any]]:
    """
    Callback executed *before* a tool function runs.
    Injects dynamic_auth_config for snow_connector_tool functions if token exists.
    """
    logger.info(f"--- Intercepted Before Tool Run ---")
    logger.info(f"Tool Name: {tool.name}")
    logger.info(f"Original Arguments: {args}")

    # Check if this is a tool generated by the snow_connector_tool toolset
    if tool.name.startswith(SNOW_CONNECTOR_TOOL_PREFIX):
        _inject_dynamic_auth(tool, args, tool_context, SNOW_ACCESS_TOKEN_KEY)
    # --- Add checks for other tool prefixes and call their specific helpers here ---
    # Example:
    # elif tool.name.startswith(OTHER_CONNECTOR_PREFIX):
        # _inject_dynamic_auth(tool, args, tool_context, OTHER_ACCESS_TOKEN_KEY)

    logger.info(f"-------------------------------------")
    # Return the potentially modified arguments
    return None

def _extract_oauth_tokens_from_state(tool: BaseTool, tool_context: ToolContext) -> tuple[Optional[str], Optional[str]]:
    """
    Extracts access and refresh tokens from session state after an OAuth tool run.

    Args:
        tool: The tool that just ran.
        tool_context: The context containing the session state.

    Returns:
        A tuple containing (access_token, refresh_token), or (None, None) if not found.
    """
    access_token = None
    refresh_token = None

    # Check if the tool has the necessary auth scheme and credential attributes
    if not (hasattr(tool, 'auth_scheme') and tool.auth_scheme and
            hasattr(tool, 'auth_credential') and tool.auth_credential):
        logger.info(f"Tool '{tool.name}' does not have required auth_scheme/auth_credential attributes. Skipping token extraction.")
        return None, None

    try:
        # Construct AuthConfig from the tool's attributes
        tool_auth_config = AuthConfig(auth_scheme=tool.auth_scheme, raw_auth_credential=tool.auth_credential)
        logger.info(f"Constructed AuthConfig for '{tool.name}': {tool_auth_config}")

        auth_handler = AuthHandler(tool_auth_config)
        credential_key = auth_handler.get_credential_key()
        logger.info(f"Calculated credential key for '{tool.name}': {credential_key}")

        session_state = tool_context.state
        if credential_key in session_state:
            credential_data = session_state[credential_key]
            # Log the specific credential data found using repr for detailed structure
            logger.info(f"Raw credential data found for key '{credential_key}': {repr(credential_data)}")

            logger.info(f"Found credential data using key '{credential_key}': {credential_data}")
            if (credential_data and credential_data.oauth2 and credential_data.oauth2.token
                    and isinstance(credential_data.oauth2.token, dict)):
                access_token = credential_data.oauth2.token.get('access_token')
                refresh_token = credential_data.oauth2.token.get('refresh_token')
                logger.info(f"Extracted tokens: Access token {'found' if access_token else 'not found'}, Refresh token {'found' if refresh_token else 'not found'}")
    except Exception as e:
        logger.error(f"Error extracting tokens for tool '{tool.name}': {e}")

    return access_token, refresh_token

def after_tool_run_interceptor(
    tool: BaseTool,
    args: Dict[str, Any],
    tool_context: ToolContext,
    tool_response: Dict[str, Any]
) -> Optional[Dict[str, Any]]:
    """
    Callback executed *after* a tool function runs.
    Accesses session state and logs information.
    Specifically extracts the ServiceNow access token after login.
    """
    logger.info(f"--- Intercepted After Tool Run ---")
    logger.info(f"Tool Name: {tool.name}")
    logger.info(f"Arguments Passed: {args}")
    # Avoid logging potentially large responses unless needed for debugging
    # logger.info(f"Tool Response: {tool_response}")

    # Access session state via ToolContext -> InvocationContext
    session_state = tool_context.state

    # Convert state to dict for easier inspection/logging if needed, but operate on the State object
    session_state_dict_before = session_state.to_dict()
    logger.info(f"Session State Before Interception: {session_state_dict_before}")

    # --- Generic Auth Token Extraction Logic ---
    # Attempt to extract tokens if the tool has auth config (might have completed auth)
    # extracted_access_token, extracted_refresh_token = _extract_oauth_tokens_from_state(tool, tool_context)

    # --- Tool-Specific Logic (e.g., Storing SNOW tokens) ---
    # Decide what to do with the extracted tokens based on the tool that ran
    if tool.name == SNOW_LOGIN_TOOL_NAME:
        extracted_access_token, extracted_refresh_token = _extract_oauth_tokens_from_state(tool, tool_context)
        if extracted_access_token:
            # Store the extracted token under the desired key
            session_state[SNOW_ACCESS_TOKEN_KEY] = extracted_access_token
            logger.info(f"Stored extracted token in session state under key '{SNOW_ACCESS_TOKEN_KEY}'.")
            if extracted_refresh_token:
                session_state[SNOW_REFRESH_TOKEN_KEY] = extracted_refresh_token
                logger.info(f"Stored extracted refresh token in session state under key '{SNOW_REFRESH_TOKEN_KEY}'.")
        else:
            logger.warning(f"Could not find or extract access token after tool '{SNOW_LOGIN_TOOL_NAME}' ran.")
    # elif tool.name == OTHER_LOGIN_TOOL_NAME:
        # extracted_access_token, extracted_refresh_token = _extract_oauth_tokens_from_state(tool, tool_context)
        # if extracted_access_token:
        #     # Store the extracted token under the desired key
        #     session_state[OTHER_ACCESS_TOKEN_KEY] = extracted_access_token
        #     logger.info(f"Stored extracted token in session state under key '{OTHER_ACCESS_TOKEN_KEY}'.")
        #     if extracted_refresh_token:
        #         session_state[OTHER_REFRESH_TOKEN_KEY] = extracted_refresh_token
        #         logger.info(f"Stored extracted refresh token in session state under key '{OTHER_REFRESH_TOKEN_KEY}'.")
        # else:
        #     logger.warning(f"Could not find or extract access token after tool '{OTHER_LOGIN_TOOL_NAME}' ran.")

    # Example: Modify state (ensure SessionService allows mutation or reassign)
    # if 'after_call_count' not in session_state:
    #     session_state['after_call_count'] = 0
    # session_state['after_call_count'] += 1
    # session_state['last_tool_called_via_after_callback'] = tool.name

    # If using InMemorySessionService, dict modifications usually persist.
    # For other services, you might need:
    # tool_context.state = session_state

    logger.info(f"Session State After Interception: {session_state.to_dict()}")
    logger.info(f"------------------------------------")

    # You can optionally modify the tool_response here if needed
    # For example:
    # if 'result' in tool_response:
    #    tool_response['result'] = "Intercepted: " + str(tool_response['result'])

    # Return None to use the original tool_response, or return a modified dict
    return None # Or return tool_response if you modified it